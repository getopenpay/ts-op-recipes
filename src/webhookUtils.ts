import * as crypto from 'crypto';

const EXPECTED_TIMESTAMP_MARKER = 't';

/**
 * Raised when a webhook event signature is invalid.
 */
class InvalidSignatureError extends Error {
  constructor() {
    super('Invalid signature');
    this.name = 'InvalidSignatureError';
  }
}

/**
 * Supported signature versions.
 */
enum SignatureVersion {
  V1 = 'v1'
}

class WebhookUtils {
  constructor() {}

  /**
   * Verification algorithm for OpenPay v1 event signatures.
   * See _verifySignature for usage.
   */
  private _verifyV1Signature(
    payload: string,
    timestamp: number,
    secretKey: string,
    signatureDigest: string
  ): boolean {
    const signaturePayload = `${timestamp}.${payload}`;
    const expectedSignature = crypto.createHmac('sha256', secretKey)
      .update(signaturePayload)
      .digest('hex');

    // Use a timing-safe comparison
    return crypto.timingSafeEqual(
      Buffer.from(signatureDigest),
      Buffer.from(expectedSignature)
    );
  }

  /**
   * Verifies the signature string for the event message.
   *
   * @param version - The signature version.
   * @param payload - The serialized event data JSON.
   * @param timestamp - The timestamp of the signature.
   * @param secretKey - The secret key to use for the signature.
   * @param signatureDigest - The signature digest to validate.
   * @returns True if the signature is valid, False otherwise.
   * @throws Error if the signature version is not supported.
   */
  private _verifySignature(
    version: string,
    payload: string,
    timestamp: number,
    secretKey: string,
    signatureDigest: string
  ): boolean {
    // Check if version is a valid SignatureVersion
    if (!Object.values(SignatureVersion).includes(version as SignatureVersion)) {
      throw new Error(`Signature version ${version} is not supported`);
    }

    if (version === SignatureVersion.V1) {
      return this._verifyV1Signature(
        payload,
        timestamp,
        secretKey,
        signatureDigest
      );
    }

    // Should never reach here if all enum values are properly handled
    return false;
  }

  /**
   * Extracts the timestamp from the signature digest.
   *
   * @param signatureDigest - The signature digest to extract the timestamp from.
   * @returns The timestamp extracted from the signature digest.
   */
  extractTimestampFromDigest(signatureDigest: string): number {
    const parts = signatureDigest.split(',');
    const [timestampMarker, timestampValue] = parts[0].split('=');

    if (timestampMarker !== EXPECTED_TIMESTAMP_MARKER) {
      throw new InvalidSignatureError();
    }

    const timestamp = parseInt(timestampValue, 10);
    if (isNaN(timestamp)) {
      throw new InvalidSignatureError();
    }

    return timestamp;
  }

  /**
   * Validates a webhook event payload using the value of the
   * signature digest header and a secret key.
   *
   * @param eventData - The serialized event data JSON. This is the value of the `data` field in the event payload.
   * @param signatureDigest - The signature digest to validate. This is the value of the `signature-digest` field in the event payload.
   * @param secret - The secret key to use for the signature. This is autogenerated when you create a webhook endpoint. You can find it in the OpenPay dashboard.
   * @throws InvalidSignatureError if the signature is invalid.
   */
  validatePayload(eventData: string, signatureDigest: string, secret: string): void {
    const timestamp = this.extractTimestampFromDigest(signatureDigest);
    const parts = signatureDigest.split(',');
    const digestTuples = parts.slice(1).map(p => p.split('='));

    const verifiedSignatures = digestTuples.map(([digestVersion, digest]) => {
      return this._verifySignature(
        digestVersion,
        eventData,
        timestamp,
        secret,
        digest
      );
    });

    if (!verifiedSignatures.some(Boolean)) {
      throw new InvalidSignatureError();
    }
  }
}

export { InvalidSignatureError, SignatureVersion, WebhookUtils };